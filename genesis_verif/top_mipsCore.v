//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/v/s/r/vsriva10/EEE591/HW2/starter-02/primitives/top_mipsCore.vp
//  Source template: top_mipsCore
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

module top_mipsCore ();



//******************************************************//
//Local Tesnch Signals
//******************************************************//
// I Cache Signals

//real [31:0] clk_count , inst_count;
real clk_count , inst_count;
logic             trig_Clk_Count;
real ipc;
logic [31:0] iCacheReadData;
logic [31:0]     iCacheReadAddr;
//******************************************************//
// D Cache Signals

logic [31:0] dCacheReadData;
logic [31:0] dCacheWriteData;
logic [31:0] dCacheAddr;
logic dCacheWriteEn;
logic dCacheReadEn;


//******************************************************//
// RF signals 

	logic [31:0] rfReadData_p0;
        logic [4:0] rfReadAddr_p0;
        logic rfReadEn_p0;
	logic [31:0] rfReadData_p1;
        logic [4:0] rfReadAddr_p1;
        logic rfReadEn_p1;
        logic [31:0] rfWriteData_p0;
	logic [4:0] rfWriteAddr_p0;
	logic rfWriteEn_p0;



//******************************************************//

logic [33:0] btbReadData;
logic [33:0] btbWriteData;
logic [31:0] btbWriteAddr;
logic [31:0] btbReadAddr;
logic btbWriteEn;
logic btbReadEn;

logic clk;
logic rst;


//******************************************************//

MIPSICache_unq1  mipsIC  (.iCacheReadData(iCacheReadData), .iCacheReadAddr(iCacheReadAddr));


MIPSDCache_unq1  mipsDC  (.dCacheWriteData(dCacheWriteData), .dCacheAddr(dCacheAddr), .dCacheWriteEn(dCacheWriteEn), .dCacheReadEn(dCacheReadEn), .dCacheReadData(dCacheReadData), .clk(clk));


MIPSRegisterFile_unq1  mipsRF  
(
	.rfWriteData_p0(rfWriteData_p0),
    	.rfWriteAddr_p0(rfWriteAddr_p0),
	.rfWriteEn_p0(rfWriteEn_p0),

    	.rfReadAddr_p0(rfReadAddr_p0),
	.rfReadData_p0(rfReadData_p0),
	.rfReadEn_p0(rfReadEn_p0),
    	.rfReadAddr_p1(rfReadAddr_p1),
	.rfReadData_p1(rfReadData_p1),
	.rfReadEn_p1(rfReadEn_p1),

	.clk(clk)
);


mipsCore  my_mipsCore
(
.iCacheReadData(iCacheReadData),
.iCacheReadAddr(iCacheReadAddr),

.dCacheReadData(dCacheReadData),
.dCacheWriteData(dCacheWriteData),
.dCacheAddr(dCacheAddr),
.dCacheWriteEn(dCacheWriteEn),
.dCacheReadEn(dCacheReadEn),


	.rfReadData_p0(rfReadData_p0),
        .rfReadAddr_p0(rfReadAddr_p0),
        .rfReadEn_p0(rfReadEn_p0),
	.rfReadData_p1(rfReadData_p1),
        .rfReadAddr_p1(rfReadAddr_p1),
        .rfReadEn_p1(rfReadEn_p1),
        .rfWriteData_p0(rfWriteData_p0),
	.rfWriteAddr_p0(rfWriteAddr_p0),
	.rfWriteEn_p0(rfWriteEn_p0),

.clk(clk),
.rst(rst)
);

initial
begin
	clk=1'b0;
//	#30
	forever
	#5 clk = ~clk;
end


task load_rfmem;
		$readmemb("rf_mem.txt",mipsRF.mem);
endtask

task load_imem;
	logic [31:0] index;
	int r;
	int fileIcache;
	fileIcache = $fopen("icache_mem.txt","r");
	index      = 32'h400000;
	while(! $feof(fileIcache)) begin
		r = $fscanf(fileIcache, "%0b", mipsIC.mem[index]);
		index = index + 32'd4;
	end
endtask

task load_dmem;
	logic [63:0] index_d;
	int r;
	int fileDcache;
	fileDcache = $fopen("dcache_mem.txt","r");
	index_d      = 64'h00000000;
	while(! $feof(fileDcache)) begin
		r = $fscanf(fileDcache, "%0b", mipsDC.mem[index_d]);
		index_d = index_d + 64'd4;
	end
endtask


task reset;
	#10 rst=1'b0;
	#8 rst=1'b1;
endtask

task load_btb;
	btbReadData  = 'b0;
	btbWriteData = 'b0;
	btbWriteAddr = 'b0;
	btbReadAddr  = 'b0;
	btbWriteEn   = 'b0;
	btbReadEn    = 'b0;	
endtask

task prog_end;
	int count;
	logic [31:0] cur_pc, prev_pc;
	count  = 0;
	while(1) begin
		prev_pc  = iCacheReadAddr;
		#20
		cur_pc   = iCacheReadAddr;
		if(cur_pc == prev_pc) begin
			count++;
		end
		if(count > 0)
			break;
	end
endtask

initial begin
	$display("************** TESTCASE STARTED***************");
	trig_Clk_Count = 1'b0;
	inst_count = 32'b0;
	clk_count  = 32'b0;
	rst        = 1'b1;
	load_rfmem();
	load_imem();
	load_dmem();	
	load_btb();
	reset();
	trig_Clk_Count = 1'b1;
	prog_end();

        if(mipsDC.mem[2147479536] != 32'd1) begin
//		$display("************** PALINDROME FAILURE***************");
//		$display("DATA CACHE ADDR = 0x7FFFEFF0  :  Expected = %0d , Got = %0h", 1,  mipsDC.mem[2147479536]);
	end
	else begin 
//		$display("************** PALINDROME SUCCESS***************");
//		$display("DATA CACHE ADDR = 0x7FFFEFF0  :  Expected = %0d , Got = %0h", 1,  mipsDC.mem[2147479536]);
	end

	trig_Clk_Count = 1'b0;
//	$display("INST COUNT  = %0d", inst_count);
//	$display("CLOCK COUNT = %0d", clk_count);

	ipc = inst_count/clk_count * 1.0;
//	$display("IPC = %0b",ipc);
//	$display("************** TESTCASE ENDED ***************");
		 
	$finish; 
end

always @(iCacheReadAddr) begin
//	$display(" PC = %0h, INSTR = %0b OPCODE = %0b, FUNCT = %0b", iCacheReadAddr, iCacheReadData, iCacheReadData[5:0], iCacheReadData[31:26]);
	if((iCacheReadData != 32'b0))
		inst_count = inst_count + 1'b1;
end

always @(posedge clk) begin
	if(trig_Clk_Count == 1'b1)
		clk_count = clk_count + 1'b1 ;
//	if(clk_count == 200) begin
//		$finish;
//	end
end

//Capture the waves in top_HelloWorld.vp
initial begin
// if this is a "+wave" run, it must record all signals
if ( $test$plusargs("wave") ) begin
$display("%t: Starting Wave Capture",$time);
// levels, instance
$vcdpluson(0, my_mipsCore );
$vcdplusmemon(0, my_mipsCore );
$vcdpluson(0, top_mipsCore );
$vcdplusmemon(0, top_mipsCore );
end
end // initial begin

endmodule







